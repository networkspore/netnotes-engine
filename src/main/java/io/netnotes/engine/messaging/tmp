        
    public static Future<?> writeEncryptedStreamToStream(
            SecurityHeaderV1 header,
            PipedOutputStream inputDataStream,
            PipedOutputStream outputEncryptedStream,
            ExecutorService execService,
            EventHandler<WorkerStateEvent> onSucceeded,
            EventHandler<WorkerStateEvent> onFailed,
            StreamProgressTracker progressTracker) {
        
        Task<Object> task = new Task<Object>() {
            @Override
            public Object call() throws Exception {
                PipedInputStream dataInput = null;
                NoteBytesWriter writer = null;
                
                NoteBytes securityLevel = header.getSecurityLevel();

                try {
                    dataInput = new PipedInputStream(inputDataStream, StreamUtils.PIPE_BUFFER_SIZE);
                    writer = new NoteBytesWriter(outputEncryptedStream);

                    
                    
                    if ( securityLevel.equals(SecurityLevel.SECURITY_PLAINTEXT)) {
                        return processPlaintextEncryption( dataInput, writer, bufferedOutput, progressTracker);

                    } else if (securityLevel.equals(SecurityLevel.SECURITY_SIGNED)) {
                        return processSignedEncryption(version, dataInput, writer, bufferedOutput, 
                                                     senderPrivateKey, senderPublicKey, progressTracker);
                    } else if (securityLevel.equals(SecurityLevel.SECURITY_SEALED)) {
                        return processSealedEncryption(version, dataInput, writer, bufferedOutput,
                                                     senderPrivateKey, senderPublicKey, recipientPublicKey, progressTracker);
                    } else {
                        throw new IllegalArgumentException("Unknown security level: " + securityLevel);
                    }
                    
                } catch (Exception e) {
                    if (progressTracker != null) {
                        progressTracker.cancel();
                    }
                    throw new RuntimeException("Encryption failed", e);
                } finally {
                    safeClose(dataInput);
                    safeClose(writer);
                    safeClose(bufferedOutput);
                }
            }
            
     
            private Object processSignedEncryption(PipedInputStream dataInput,
                                     NoteBytesWriter writer, OutputStream output,
                                     NoteBytes senderPrivateKey, NoteBytes senderPublicKey,
                                     StreamProgressTracker progressTracker) throws Exception {
    
                Ed25519Signer signer = new Ed25519Signer();
                Ed25519PrivateKeyParameters privateKey = new Ed25519PrivateKeyParameters(senderPrivateKey.getBytes(), 0);
                signer.init(true, privateKey);
                
                // Stream the data while building signature
                ByteArrayOutputStream dataBuffer = new ByteArrayOutputStream();
                byte[] buffer = new byte[StreamUtils.BUFFER_SIZE];
                int bytesRead;
                long totalBytes = 0;
                
                while ((bytesRead = dataInput.read(buffer)) != -1) {
                    if (progressTracker != null && progressTracker.isCancelled()) {
                        throw new InterruptedException("Operation cancelled");
                    }
                    
                    dataBuffer.write(buffer, 0, bytesRead);
                    signer.update(buffer, 0, bytesRead);
                    totalBytes += bytesRead;
                    
                    if (progressTracker != null) {
                        progressTracker.addBytesProcessed(bytesRead);
                    }
                }
                
                byte[] signature = signer.generateSignature();
                
                // Write header with signature
                writer.write(MessageHeader.getSecuritySignedHeader(version, senderPublicKey, signature, totalBytes));
                writer.flush();
                
                // Write signed data directly
                output.write(dataBuffer.toByteArray());
                
                return null;
            }
            
            private Object processSealedEncryption(NoteBytes version, PipedInputStream dataInput,
                                     NoteBytesWriter writer, OutputStream output,
                                     NoteBytes senderPrivateKey, NoteBytes senderPublicKey,
                                     NoteBytes recipientPublicKey,
                                     StreamProgressTracker progressTracker) throws Exception {
    
                // Generate ephemeral key pair
                SecureRandom random = new SecureRandom();
                X25519PrivateKeyParameters ephemeralPrivate = new X25519PrivateKeyParameters(random);
                X25519PublicKeyParameters ephemeralPublic = ephemeralPrivate.generatePublicKey();
                
                // Perform ECDH key agreement
                X25519Agreement agreement = new X25519Agreement();
                agreement.init(ephemeralPrivate);
                byte[] sharedSecret = new byte[32];
                X25519PublicKeyParameters recipientKey = new X25519PublicKeyParameters(recipientPublicKey.getBytes(), 0);
                agreement.calculateAgreement(recipientKey, sharedSecret, 0);
                
                // Derive encryption key using HKDF
                NoteBytes encryptionKey = deriveKey(sharedSecret, CHA_CHA_20_POLY_1305_ALGORITHM, CHACHA20_KEY_SIZE);
                NoteBytes nonce = new NoteRandom(CHACHA20_NONCE_SIZE);
                
                // Write header
                writer.write(MessageHeader.getSecuritySealedHeader(
                    version, 
                    senderPublicKey,  
                    new NoteBytes(ephemeralPublic.getEncoded()), 
                    nonce, 
                    CHA_CHA_20_POLY_1305_ALGORITHM));
                writer.flush();
                
                // Direct encryption - CipherOutputStream handles buffering
                streamEncrypt(dataInput, output, encryptionKey, nonce, progressTracker);
                
                return null;
            }
            
            private void streamEncrypt(InputStream input, OutputStream output, 
                         NoteBytes key, NoteBytes nonce,
                         StreamProgressTracker progressTracker) throws Exception {
    
                Cipher cipher = Cipher.getInstance("ChaCha20-Poly1305", "BC");
                SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(), "ChaCha20");
                ChaCha20ParameterSpec paramSpec = new ChaCha20ParameterSpec(nonce.getBytes(), 1);
                cipher.init(Cipher.ENCRYPT_MODE, keySpec, paramSpec);
                
                // CipherOutputStream handles buffering and AEAD finalization
                try (CipherOutputStream cipherOut = new CipherOutputStream(output, cipher)) {
                    streamCopy(input, cipherOut, progressTracker);
                }
            }
            
            
            
            private NoteBytes deriveKey(byte[] sharedSecret, NoteBytes info, int keyLength) throws Exception {
                HKDFBytesGenerator hkdf = new HKDFBytesGenerator(new SHA256Digest());
                hkdf.init(new HKDFParameters(sharedSecret, null, info.getBytes()));
                byte[] derivedKey = new byte[keyLength];
                hkdf.generateBytes(derivedKey, 0, keyLength);
                return new NoteBytesReadOnly(derivedKey);
            }
           
        };
        
        task.setOnSucceeded(onSucceeded);
        task.setOnFailed(onFailed);
        
        return execService.submit(task);
    }
