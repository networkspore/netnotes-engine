 // Main method - simplified return type and better resource management
    protected CompletableFuture<NoteBytesObject> startRead(PipedOutputStream pipedOutput) {
        AtomicBoolean lockAcquired = new AtomicBoolean(false);
        
        return CompletableFuture
            .supplyAsync(() -> {
                try {
                    getDataSemaphore().acquire();
                    lockAcquired.set(true);
                    return getIdDataFile();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException("Thread interrupted while acquiring semaphore", e);
                } catch (IOException e) {
                    throw new RuntimeException("Failed to get ID data file", e);
                }
            }, getExecService())
            .thenCompose(file -> performDecryption(file, pipedOutput))
            .whenComplete((result, throwable) -> {
                // Always release semaphore regardless of success or failure
                if (lockAcquired.getAndSet(false)) {
                    getDataSemaphore().release();
                }
            });
    }

    // Refactored main method with proper CompletableFuture chaining
    public CompletableFuture<File> getIdDataFileAsync(NoteStringArrayReadOnly path) {
        AtomicBoolean lockAcquired = new AtomicBoolean(false);
        
        return CompletableFuture
            .supplyAsync(() -> {
                try {
                    getDataSemaphore().acquire();
                    lockAcquired.set(true);
                    return getIdDataFile();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException("Thread interrupted", e);
                } catch (IOException e) {
                    throw new RuntimeException("Failed to get ID data file", e);
                }
            }, getExecService())
            .thenCompose(idDataFile -> {
                File dataDir = idDataFile.getParentFile();
                
                if (idDataFile.isFile()) {
                    // File exists - process it
                    return processExistingDataFile(idDataFile, dataDir, path);
                } else {
                    // File doesn't exist - create new structure
                    return createNewDataStructure(dataDir, path);
                }
            })
            .whenComplete((result, throwable) -> {
                // Always release semaphore
                if (lockAcquired.getAndSet(false)) {
                    getDataSemaphore().release();
                }
                
                if (throwable != null) {
                    Utils.writeLogMsg("AppData.getIdDataFileAsync", throwable);
                }
            });
    }

    private CompletableFuture<File> processExistingDataFile(File idDataFile, File dataDir, NoteStringArrayReadOnly path) {
        return CompletableFuture
            .supplyAsync(() -> {
                try {
                    // Set up piped streams for concurrent processing
                    PipedOutputStream decryptedOutput = new PipedOutputStream();
                    PipedOutputStream parsedOutput = new PipedOutputStream();
                    
                    // Chain the operations: decrypt -> parse -> encrypt -> return file
                    CompletableFuture<NoteBytesObject> decryptFuture = 
                        performDecryption(idDataFile, decryptedOutput);
                    
                    CompletableFuture<File> parseFuture = 
                        parseIdDataFileUpdate(path, dataDir, decryptedOutput, parsedOutput);
                    
                    File tmpFile = new File(idDataFile.getAbsolutePath() + ".tmp");
                    CompletableFuture<NoteBytesObject> saveFuture = 
                        saveEncryptedFileSwap(idDataFile, tmpFile, parsedOutput);
                    
                    // Wait for all operations to complete and return the result file
                    return CompletableFuture.allOf(decryptFuture, parseFuture, saveFuture)
                        .thenCompose(v -> parseFuture) // Return the parsed file result
                        .join(); // Block for this async operation
                        
                } catch (Exception e) {
                    throw new RuntimeException("Failed to process existing data file", e);
                }
            }, getExecService());
    }

    private CompletableFuture<File> createNewDataStructure(File dataDir, NoteStringArrayReadOnly path) {
        return CompletableFuture
            .supplyAsync(() -> {
                try {
                    File newFile = createNewDataFile(dataDir);
                    
                    // Create initial tree structure
                    NoteBytesObject treeRoot = new NoteBytesObject();
                    NoteBytesObject currentNode = treeRoot;
                    
                    NoteBytes[] pathList = path.getAsArray();
                    int pathLength = pathList.length;
                    
                    for (int i = 0; i < pathLength; i++) {
                        NoteBytes bucket = pathList[i];
                        NoteBytesObject newNode = new NoteBytesObject();
                        
                        if (i == pathLength - 1) {
                            newNode.add(FILE_PATH, newFile.getAbsolutePath());
                            newNode.add(CREATED, System.currentTimeMillis());
                        }
                        
                        currentNode.add(bucket, newNode);
                        currentNode = newNode;
                    }
                    
                    FileStreamUtils.saveEncryptedFile(newFile,treeRoot.get(),getSecretKey());

                    return newFile;
                    
                } catch (Exception e) {
                    throw new RuntimeException("Failed to create new data structure", e);
                }
            }, getExecService());
    }

    // Refactored parsing method with proper return type
    private CompletableFuture<File> parseIdDataFileUpdate(NoteStringArrayReadOnly path, File dataDir, 
                                                        PipedOutputStream decryptedInputStream, 
                                                        PipedOutputStream parsedOutputStream) {
        
        return CompletableFuture
            .supplyAsync(() -> {
                // Validate inputs
                if (path == null || path.byteLength() == 0 || dataDir == null || 
                    decryptedInputStream == null || parsedOutputStream == null) {
                    throw new IllegalArgumentException("Required parameters cannot be null");
                }
                
                List<NoteBytes> targetPath = path.getAsList();
                
                try (
                    NoteBytesReader reader = new NoteBytesReader(new PipedInputStream(decryptedInputStream, StreamUtils.PIPE_BUFFER_SIZE));
                    NoteBytesWriter writer = new NoteBytesWriter(parsedOutputStream)) {
                    
                    // Read root metadata
                    NoteBytesMetaData rootMetaData = reader.nextMetaData();
                    if (rootMetaData == null) {
                        // Empty file case - create new structure
                        File newFile = createNewDataFile(dataDir);
                        NoteBytesObject rootNode = createPathStructure(targetPath, dataDir, newFile);
                        writer.write(rootNode);
                        return newFile;
                    }
                    
                    // Parse existing tree and look for target path
                    File foundFile = parseAndWriteTree(reader, writer, rootMetaData, targetPath, dataDir);
                    return foundFile;
                    
                } catch (Exception e) {
                    throw new RuntimeException("Failed to parse ID data file", e);
                }
            }, getExecService());
    }

    private File parseAndWriteTree(NoteBytesReader reader, NoteBytesWriter writer, NoteBytesMetaData rootMetaData,
                                List<NoteBytes> targetPath, File dataDir) throws IOException {
        
        if (rootMetaData.getType() != NoteBytesMetaData.NOTE_BYTES_OBJECT_TYPE) {
            throw new IOException("Root must be an object");
        }
        
        // Write root metadata
        writer.write(rootMetaData);
        
        // Parse the root object and look for target path
        FileResult result = new FileResult();
        parseObjectAndFindPath(reader, writer, rootMetaData.getLength(), targetPath, 0, dataDir, result);
        
        return result.getFile();
    }

    // Helper class to hold file result from parsing
    private static class FileResult {
        private File file;

        public void setFile(File file) {
            this.file = file;
        }
        
        public File getFile() {
            return file;
        }
    }

    private void parseObjectAndFindPath(NoteBytesReader reader, NoteBytesWriter writer, int objectLen,
                                    List<NoteBytes> targetPath, int pathIndex, File dataDir, 
                                    FileResult result) throws IOException {
        
        int bytesRead = 0;
        boolean foundPath = false;
        List<NoteBytesPair> pendingPairs = new ArrayList<>();
        
        // Read all key-value pairs in this object first
        while (bytesRead < objectLen) {
            // Read key metadata and data
            NoteBytesMetaData keyMetaData = reader.nextMetaData();
            if (keyMetaData == null || keyMetaData.getType() != NoteBytesMetaData.STRING_TYPE) {
                throw new IOException("Expected string key");
            }
            
            byte[] keyData = new byte[keyMetaData.getLength()];
            reader.read(keyData);
            bytesRead += 5 + keyMetaData.getLength();
            
            // Read value metadata and data
            NoteBytesMetaData valueMetaData = reader.nextMetaData();
            if (valueMetaData == null) {
                throw new IOException("Expected value after key");
            }
            
            byte[] valueData = new byte[valueMetaData.getLength()];
            reader.read(valueData);
            bytesRead += 5 + valueMetaData.getLength();
            
            // Store the pair for processing
            NoteBytes key = new NoteBytes(keyData, ByteDecoding.getDecodingFromType(keyMetaData.getType()));
            NoteBytes value = new NoteBytes(valueData, ByteDecoding.getDecodingFromType(valueMetaData.getType()));
            pendingPairs.add(new NoteBytesPair(key, value));
        }
        
        // Process pairs and look for target path
        for (NoteBytesPair pair : pendingPairs) {
            boolean isTargetKey = (pathIndex < targetPath.size()) && 
                                Arrays.equals(pair.getKey().get(), targetPath.get(pathIndex).get());
            
            if (isTargetKey) {
                foundPath = true;
                
                if (pathIndex == targetPath.size() - 1) {
                    // Final path element - extract file
                    File existingFile = extractFilePathFromObjectData(pair.getValue().get());
                    result.setFile(existingFile);
                    
                    // Write the pair as-is
                    writer.write(pair.getKey());
                    writer.write(pair.getValue());
                } else {
                    // Continue down the path
                    writer.write(pair.getKey());
                    writer.write(pair.getValue());
                    
                    // Parse nested object
                    parseNestedObject(reader, writer, pair.getValue().get(), targetPath, pathIndex + 1, dataDir, result);
                }
            } else {
                // Copy as-is
                writer.write(pair.getKey());
                writer.write(pair.getValue());
            }
        }
        
        // If path not found, create it
        if (!foundPath && pathIndex < targetPath.size()) {
            File newFile = createNewDataFile(dataDir);
            result.setFile(newFile);
            insertMissingPath(writer, targetPath, pathIndex, dataDir, newFile);
        }
    }

    private void parseNestedObject(NoteBytesReader reader, NoteBytesWriter writer, byte[] objectData,
                                List<NoteBytes> targetPath, int pathIndex, File dataDir, 
                                FileResult result) throws IOException {
        
        // Create readers/writers for nested processing
        try (ByteArrayInputStream bais = new ByteArrayInputStream(objectData);
            NoteBytesReader nestedReader = new NoteBytesReader(bais);
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            NoteBytesWriter nestedWriter = new NoteBytesWriter(baos)) {
            
            parseObjectAndFindPath(nestedReader, nestedWriter, objectData.length, targetPath, pathIndex, dataDir, result);
            
            // Write processed data
            writer.write(baos.toByteArray());
        }
    }

    private File extractFilePathFromObjectData(byte[] objectData) throws IOException {
        NoteBytesObject obj = new NoteBytesObject(objectData);
        NoteBytesPair filePathPair = obj.get(FILE_PATH);
        
        if (filePathPair == null || filePathPair.getValue().getByteDecoding().getType() != NoteBytesMetaData.STRING_TYPE) {
            throw new IOException("No valid filePath found in object");
        }
        
        String filePath = filePathPair.getValue().getAsString();
        return new File(filePath);
    }

    private void insertMissingPath(NoteBytesWriter writer, List<NoteBytes> targetPath, int startIndex,
                                File dataDir, File resultFile) throws IOException {
        
        NoteBytesObject pathStructure = buildPathStructure(targetPath, startIndex, dataDir, resultFile);
        writer.write(pathStructure);
    }

    private NoteBytesObject buildPathStructure(List<NoteBytes> targetPath, int startIndex, File dataDir, File resultFile) throws IOException {
        if (startIndex >= targetPath.size()) {
            return new NoteBytesObject();
        }
        
        NoteBytesObject currentObj = new NoteBytesObject();
        NoteBytes currentKey = targetPath.get(startIndex);
        
        if (startIndex == targetPath.size() - 1) {
            // Final element - use provided result file
            NoteBytesObject fileObj = new NoteBytesObject();
            fileObj.add(FILE_PATH, new NoteBytes(resultFile.getCanonicalPath()));
            fileObj.add(CREATED, new NoteBytes(System.currentTimeMillis()));
            currentObj.add(currentKey, fileObj);
        } else {
            // Intermediate element
            NoteBytesObject nestedObj = buildPathStructure(targetPath, startIndex + 1, dataDir, resultFile);
            currentObj.add(currentKey, nestedObj);
        }
        
        return currentObj;
    }

    private NoteBytesObject createPathStructure(List<NoteBytes> targetPath, File dataDir, File resultFile) throws IOException {
        return buildPathStructure(targetPath, 0, dataDir, resultFile);
    }
