    private Future<?> updateDataEncryption(SecretKey oldKey, SecretKey newKey, EventHandler<WorkerStateEvent> onSucceeded, EventHandler<WorkerStateEvent> onFailed) throws IOException {
        Task<Object> task = new Task<Object>() {
            @Override
            public Object call() throws Exception {
                File idDataFile = getIdDataFile();
                File dataDir = idDataFile.getParentFile();
                
                if (idDataFile.isFile()) {
                    // Set up concurrent processing streams
                    PipedOutputStream decryptedOutput = new PipedOutputStream();
                    PipedOutputStream parsedOutput = new PipedOutputStream();
                    
                    // Start decryption stream with old key
                    FileStreamUtils.readEncryptedDataStream(idDataFile, oldKey, getExecService(), decryptedOutput);
                    
                    updateDataEncryption(oldKey, newKey,dataDir, decryptedOutput, parsedOutput,onSucceeded);
                    
                    // Write encrypted output with new key
                    File tmpFile = new File(dataDir.getAbsolutePath() + "/" + NoteUUID.createSafeUUID128() + ".tmp");
                    FileStreamUtils.writeEncryptedDataStream(idDataFile, tmpFile, newKey, parsedOutput, getExecService(), onSucceeded, onFailed);
                }
                
                return true;
            }
        };
        
        task.setOnFailed(onFailed);
        return getExecService().submit(task);
    }

    private Future<?> updateDataEncryption( SecretKey oldKey, SecretKey newKey, File dataDir, PipedOutputStream decryptedOutputStream, 
                                        PipedOutputStream parsedOutputStream, EventHandler<WorkerStateEvent> onSucceeded) {
        Task<Object> task = new Task<Object>() {
            @Override
            public Object call() throws IOException {
         
               
                try (
                    PipedInputStream parsedInputStream = new PipedInputStream(decryptedOutputStream);
                    NoteBytesReader reader = new NoteBytesReader(parsedInputStream);
                    NoteBytesWriter writer = new NoteBytesWriter(parsedOutputStream)
                ) {
                    // Read root metadata
                    NoteBytesMetaData rootMetaData = reader.nextMetaData();
                    if (rootMetaData == null) {
                        // Empty file case - nothing to update
                        if (onSucceeded != null) {
                            Utils.returnObject(true, getExecService(), onSucceeded);
                        }
                        return true;
                    }
                    
                    // Parse and update the entire tree
                    parseAndUpdateTree(reader, writer, rootMetaData, dataDir, oldKey, newKey);
                    
                    if (onSucceeded != null) {
                        Utils.returnObject(true, getExecService(), onSucceeded);
                    }
                    return true;
                }
            }
        };
        return getExecService().submit(task);
    }
    
    private void parseAndUpdateTree(NoteBytesReader reader, NoteBytesWriter writer, NoteBytesMetaData rootMetaData, 
                               File dataDir, SecretKey oldKey, SecretKey newKey) throws IOException {
    
        if (rootMetaData.getType() != NoteBytesMetaData.NOTE_BYTES_OBJECT_TYPE) {
            throw new IOException("Root must be an object");
        }
        
        // Write root metadata
        writer.write(rootMetaData);
        
        // Parse the root object and update all files
        parseObjectAndUpdateFiles(reader, writer, rootMetaData.getLength(), dataDir, oldKey, newKey);
    }

    private void parseObjectAndUpdateFiles(NoteBytesReader reader, NoteBytesWriter writer, int objectLen, 
                                      File dataDir, SecretKey oldKey, SecretKey newKey) throws IOException {
    
        int bytesRead = 0;
        List<NoteBytesPair> pendingPairs = new ArrayList<>();
        
        // Read all key-value pairs in this object first
        while (bytesRead < objectLen) {
            // Read key metadata
            NoteBytesMetaData keyMetaData = reader.nextMetaData();
            if (keyMetaData == null || keyMetaData.getType() != NoteBytesMetaData.STRING_TYPE) {
                throw new IOException("Expected string key");
            }
            
            // Read key data
            byte[] keyData = reader.readByteAmount(keyMetaData.getLength());
            bytesRead += 5 + keyMetaData.getLength();
            
            // Read value metadata
            NoteBytesMetaData valueMetaData = reader.nextMetaData();
            if (valueMetaData == null) {
                throw new IOException("Expected value after key");
            }
            
            // Read value data
            byte[] valueData = reader.readByteAmount(valueMetaData.getLength());
            bytesRead += 5 + valueMetaData.getLength();
            
            // Create NoteBytes objects and store the pair
            NoteBytes key = new NoteBytes(keyData, ByteDecoding.getDecodingFromType(keyMetaData.getType()));
            NoteBytes value = new NoteBytes(valueData, ByteDecoding.getDecodingFromType(valueMetaData.getType()));
            pendingPairs.add(new NoteBytesPair(key, value));
        }
        
        // Process all pairs - look for filePath entries and nested objects
        for (NoteBytesPair pair : pendingPairs) {
      
            if (FILE_PATH.equals(pair.getKey()) && pair.getValue().getByteDecoding().getType() == NoteBytesMetaData.STRING_TYPE) {
                // Found a filePath - update the file encryption
                String filePath = pair.getAsString();
                File file = new File(filePath);
                if (file.exists()) {
                    UpdateFileEncryption(file, dataDir, oldKey, newKey);
                }
                
                // Write the pair as-is (filePath doesn't change, just the file content)
                writer.write(pair);
                
            } else if (pair.getValue().getByteDecoding().getType() == NoteBytesMetaData.NOTE_BYTES_OBJECT_TYPE) {
                // This is a nested object - recurse into it
                writer.write(pair.getKey());
                
                // Parse and update the nested object
                parseNestedObjectAndUpdate(writer, pair.getValue().get(), dataDir, oldKey, newKey);
                
            } else {
                // Regular key-value pair (like "created" timestamp) - copy as-is
                writer.write(pair);
            }
        }
    }

    private void parseNestedObjectAndUpdate(NoteBytesWriter writer, byte[] objectData, File dataDir, 
                                        SecretKey oldKey, SecretKey newKey) throws IOException {
        
        // Create a temporary reader for the nested object data
        ByteArrayInputStream bais = new ByteArrayInputStream(objectData);
        NoteBytesReader nestedReader = new NoteBytesReader(bais);
        
        // Use a ByteArrayOutputStream to capture what we write for the nested object
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        NoteBytesWriter nestedWriter = new NoteBytesWriter(baos);
        
        // Parse the nested object content
        parseObjectContentAndUpdate(nestedReader, nestedWriter, objectData.length, dataDir, oldKey, newKey);
        
        // Write the processed nested object data
        byte[] processedData = baos.toByteArray();
        
        // Write metadata for the nested object
        NoteBytesMetaData objectMetaData = new NoteBytesMetaData(NoteBytesMetaData.NOTE_BYTES_OBJECT_TYPE, processedData.length);
        writer.write(objectMetaData);
        writer.write(processedData);
    }

    private void parseObjectContentAndUpdate(NoteBytesReader reader, NoteBytesWriter writer, int objectLen,
                                            File dataDir, SecretKey oldKey, SecretKey newKey) throws IOException {
        
        int bytesRead = 0;
        
        while (bytesRead < objectLen) {
            // Read key metadata
            NoteBytesMetaData keyMetaData = reader.nextMetaData();
            if (keyMetaData == null) break;
            
            // Read key data
            byte[] keyData = reader.readByteAmount(keyMetaData.getLength());
            bytesRead += 5 + keyMetaData.getLength();
            
            NoteBytes key = new NoteBytes(keyData, keyMetaData.getType());

            // Read value metadata
            NoteBytesMetaData valueMetaData = reader.nextMetaData();
            if (valueMetaData == null) break;
            
            // Read value data
            byte[] valueData = reader.readByteAmount(valueMetaData.getLength());
            bytesRead += 5 + valueMetaData.getLength();

            NoteBytes value = new NoteBytes(valueData, valueMetaData.getType());
             
            if (FILE_PATH.equals(key) && valueMetaData.getType() == NoteBytesMetaData.STRING_TYPE) {
                // Found a filePath - update the file encryption
                String filePath = value.getAsString(); // Might need specific encoding
                File file = new File(filePath);
                if (file.exists()) {
                    UpdateFileEncryption(file, dataDir, oldKey, newKey);
                }
            }
            
            // Always write the data (whether it's a filePath, nested object, or other data)
            writer.write(keyMetaData);
            writer.write(keyData);
            
            if (valueMetaData.getType() == NoteBytesMetaData.NOTE_BYTES_OBJECT_TYPE) {
                // Recursively process nested objects
                parseNestedObjectAndUpdate(writer, valueData, dataDir, oldKey, newKey);
            } else {
                // Write regular value as-is
                writer.write(valueMetaData);
                writer.write(valueData);
            }
        }
    }

    private void UpdateFileEncryption(File file, File dataDir, SecretKey oldKey, SecretKey newKey)  {
        
        File tmpFile = new File(dataDir.getAbsolutePath() + "/" +  NoteUUID.createSafeUUID128() + ".tmp");
        try {
            FileStreamUtils.updateFileEncryption(oldKey, newKey, file, tmpFile);
        } catch (Exception e) {
            Utils.writeLogMsg("AppData.UpdateFileEncryption", file.getName() + ":" + e.toString());
        }
    }
